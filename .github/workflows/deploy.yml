name: Build and Deploy to AWS ECS

on:
  push:
    branches: [main]
  pull_request:
    branches: [main]

env:
  AWS_REGION: eu-north-1
  ECR_BACKEND_REPO: shipments-backend
  ECR_FRONTEND_REPO: shipments-frontend
  ECS_CLUSTER: arn:aws:ecs:eu-north-1:354918374652:cluster/HappyRobot-ECS
  ECS_SERVICE: arn:aws:ecs:eu-north-1:354918374652:service/HappyRobot-ECS/shipments-taskdef-service-f8gz4zjz
  TASK_DEF_FAMILY: shipments-taskdef
  # Runtime roles used by the ECS task definition (ECS will assume these, not GitHub)
  EXECUTION_ROLE_ARN: arn:aws:iam::354918374652:role/ecsTaskExecutionRole
  TASK_ROLE_ARN: ""   # Optionally set to your app role ARN; leave empty to remove taskRoleArn
  # Container names in your task def
  CONTAINER_BACKEND: backend
  CONTAINER_FRONTEND: frontend
  # Load balancer target groups (update these with your actual target group ARNs)
  FRONTEND_TARGET_GROUP_ARN: arn:aws:elasticloadbalancing:eu-north-1:354918374652:targetgroup/APP-frontend/7a02fc7c09914764  # Set this to your frontend target group ARN
  BACKEND_TARGET_GROUP_ARN: arn:aws:elasticloadbalancing:eu-north-1:354918374652:targetgroup/APP-backend/22b79997edea2035   # Set this to your backend target group ARN

jobs:
  build-and-push:
    name: Build and Push Images
    runs-on: ubuntu-latest
    permissions:
      id-token: write
      contents: read

    outputs:
      backend-image: ${{ steps.build-backend.outputs.backend-image }}
      frontend-image: ${{ steps.build-frontend.outputs.frontend-image }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS credentials (OIDC - CI role)
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: arn:aws:iam::354918374652:role/GITHUB_deploy
          aws-region: ${{ env.AWS_REGION }}

      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2

      - name: Build, tag, and push backend image
        id: build-backend
        env:
          ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
          IMAGE_TAG: ${{ github.sha }}
        run: |
          set -euo pipefail
          docker build --progress=plain -t $ECR_REGISTRY/$ECR_BACKEND_REPO:$IMAGE_TAG ./backend
          docker tag $ECR_REGISTRY/$ECR_BACKEND_REPO:$IMAGE_TAG $ECR_REGISTRY/$ECR_BACKEND_REPO:latest
          docker push $ECR_REGISTRY/$ECR_BACKEND_REPO:$IMAGE_TAG
          docker push $ECR_REGISTRY/$ECR_BACKEND_REPO:latest
          echo "backend-image=$ECR_REGISTRY/$ECR_BACKEND_REPO:$IMAGE_TAG" >> "$GITHUB_OUTPUT"

      - name: Build, tag, and push frontend image
        id: build-frontend
        env:
          ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
          IMAGE_TAG: ${{ github.sha }}
          VITE_API_URL: ${{ secrets.ALB_URL || 'http://happyrobot-1700442240.eu-north-1.elb.amazonaws.com' }}
          VITE_API_KEY: ${{ secrets.API_KEY || 'HapRob-OTVHhErcXLu2eKkUMP6lDtrd8UNi61KZo4FvGALqem0NoJO1uWlz7OywCN0BNoNaG2x5Y' }}
        run: |
          set -euo pipefail
          docker build --progress=plain --build-arg VITE_API_URL="$VITE_API_URL" --build-arg VITE_API_KEY="$VITE_API_KEY" -t $ECR_REGISTRY/$ECR_FRONTEND_REPO:$IMAGE_TAG ./frontend
          docker tag $ECR_REGISTRY/$ECR_FRONTEND_REPO:$IMAGE_TAG $ECR_REGISTRY/$ECR_FRONTEND_REPO:latest
          docker push $ECR_REGISTRY/$ECR_FRONTEND_REPO:$IMAGE_TAG
          docker push $ECR_REGISTRY/$ECR_FRONTEND_REPO:latest
          echo "frontend-image=$ECR_REGISTRY/$ECR_FRONTEND_REPO:$IMAGE_TAG" >> "$GITHUB_OUTPUT"

  deploy:
    name: Deploy to ECS
    needs: build-and-push
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main'
    permissions:
      id-token: write
      contents: read

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS credentials (OIDC - CI role)
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: arn:aws:iam::354918374652:role/GITHUB_deploy
          aws-region: ${{ env.AWS_REGION }}

      - name: Debug - AWS identity
        run: |
          set -euo pipefail
          aws sts get-caller-identity
          aws --version

      - name: ECS resources check
        run: |
          set -euo pipefail
          aws ecs describe-clusters --clusters "${{ env.ECS_CLUSTER }}"
          aws ecs describe-services --cluster "${{ env.ECS_CLUSTER }}" --services "${{ env.ECS_SERVICE }}"
          aws ecs describe-task-definition --task-definition "${{ env.TASK_DEF_FAMILY }}"

      - name: Download task definition
        run: |
          set -euo pipefail
          aws ecs describe-task-definition \
            --task-definition "${{ env.TASK_DEF_FAMILY }}" \
            --query taskDefinition > task-definition.json
          cat task-definition.json

      - name: Patch roles and port mappings in task definition
        run: |
          set -euo pipefail
          # Always set executionRoleArn
          jq --arg exec "${{ env.EXECUTION_ROLE_ARN }}" '.executionRoleArn=$exec' task-definition.json > td1.json
          # If TASK_ROLE_ARN provided, set it; if empty, delete taskRoleArn
          if [ -n "${{ env.TASK_ROLE_ARN }}" ]; then
            jq --arg tr "${{ env.TASK_ROLE_ARN }}" '.taskRoleArn=$tr' td1.json > td2.json
          else
            jq 'del(.taskRoleArn)' td1.json > td2.json
          fi
          
          # Fix port mappings for frontend and backend containers
          jq '.containerDefinitions |= map(
            if .name == "frontend" then
              .portMappings = [{"containerPort": 80, "hostPort": 80, "protocol": "tcp"}]
            elif .name == "backend" then
              .portMappings = [{"containerPort": 8000, "hostPort": 8000, "protocol": "tcp"}]
            else
              .
            end
          )' td2.json > task-definition.patched.json
          
          echo "Patched:"
          jq '. | {family, revision, executionRoleArn, taskRoleArn}' task-definition.patched.json
          echo "Port mappings:"
          jq '.containerDefinitions[] | {name, portMappings}' task-definition.patched.json
      
      - name: Ensure awslogs config and create missing log groups
        env:
            REGION: ${{ env.AWS_REGION }}
            LOG_GROUP: /ecs/shipments
        run: |
            set -euo pipefail
        
            # Force awslogs region & group on any awslogs-enabled container
            jq --arg region "$REGION" --arg group "$LOG_GROUP" '
              .containerDefinitions |=
                (map(
                  if (.logConfiguration // empty) and (.logConfiguration.logDriver == "awslogs") then
                    .logConfiguration.options["awslogs-region"] = $region
                    | .logConfiguration.options["awslogs-group"]  = $group
                    | (.logConfiguration.options["awslogs-stream-prefix"] |= (. // "shipments"))
                  else
                    .
                  end
                ))
            ' task-definition.patched.json > task-definition.patched.logs.json
        
            mv task-definition.patched.logs.json task-definition.patched.json
        
            echo "üîé Log config summary:"
            jq '.containerDefinitions[]
                | select(.logConfiguration.logDriver=="awslogs")
                | {name, logGroup: .logConfiguration.options["awslogs-group"],
                   region: .logConfiguration.options["awslogs-region"],
                   prefix: .logConfiguration.options["awslogs-stream-prefix"]}' task-definition.patched.json
        
            # Create the log group if missing
            EXISTS=$(aws logs describe-log-groups \
              --log-group-name-prefix "$LOG_GROUP" \
              --region "$REGION" \
              --query 'logGroups[?logGroupName==`'"$LOG_GROUP"'`] | length(@)' \
              --output text)
        
            if [ "$EXISTS" = "0" ]; then
              echo "üìò Creating log group: $LOG_GROUP"
              aws logs create-log-group --log-group-name "$LOG_GROUP" --region "$REGION"
              aws logs put-retention-policy --log-group-name "$LOG_GROUP" --retention-in-days 14 --region "$REGION" || true
            else
              echo "‚úÖ Log group exists: $LOG_GROUP"
            fi
      - name: Render task def (backend)
        id: render-backend
        uses: aws-actions/amazon-ecs-render-task-definition@v1
        with:
          task-definition: task-definition.patched.json
          container-name: ${{ env.CONTAINER_BACKEND }}
          image: ${{ needs.build-and-push.outputs.backend-image }}
          environment-variables: |
            ALLOWED_ORIGINS=http://happyrobot-1700442240.eu-north-1.elb.amazonaws.com,https://happyrobot-1700442240.eu-north-1.elb.amazonaws.com

      - name: Render task def (frontend)
        id: render-frontend
        uses: aws-actions/amazon-ecs-render-task-definition@v1
        with:
          task-definition: ${{ steps.render-backend.outputs.task-definition }}
          container-name: ${{ env.CONTAINER_FRONTEND }}
          image: ${{ needs.build-and-push.outputs.frontend-image }}

      - name: Validate roles and port mappings in final task definition
        run: |
          set -euo pipefail
          FINAL="${{ steps.render-frontend.outputs.task-definition }}"
          jq '. | {family, revision, executionRoleArn, taskRoleArn}' "$FINAL"
          execRole=$(jq -r '.executionRoleArn' "$FINAL")
          taskRole=$(jq -r '.taskRoleArn // empty' "$FINAL")
          if echo "$execRole" | grep -q 'GITHUB_deploy'; then
            echo "‚ùå executionRoleArn still points to GITHUB_deploy"; exit 1
          fi
          if echo "$taskRole" | grep -q 'GITHUB_deploy'; then
            echo "‚ùå taskRoleArn still points to GITHUB_deploy"; exit 1
          fi
          echo "‚úÖ Roles look good"
          
          # Validate port mappings
          echo "üîç Validating port mappings..."
          jq '.containerDefinitions[] | {name, portMappings}' "$FINAL"
          
          # Check frontend port
          frontendPort=$(jq -r '.containerDefinitions[] | select(.name=="frontend") | .portMappings[0].containerPort' "$FINAL")
          if [ "$frontendPort" != "80" ]; then
            echo "‚ùå Frontend container port is $frontendPort, expected 80"; exit 1
          fi
          
          # Check backend port
          backendPort=$(jq -r '.containerDefinitions[] | select(.name=="backend") | .portMappings[0].containerPort' "$FINAL")
          if [ "$backendPort" != "8000" ]; then
            echo "‚ùå Backend container port is $backendPort, expected 8000"; exit 1
          fi
          
          echo "‚úÖ Port mappings look good"

      - name: Deploy Amazon ECS task definition
        uses: aws-actions/amazon-ecs-deploy-task-definition@v1
        with:
          task-definition: ${{ steps.render-frontend.outputs.task-definition }}
          service: ${{ env.ECS_SERVICE }}
          cluster: ${{ env.ECS_CLUSTER }}
          wait-for-service-stability: true

      - name: Update ECS service with load balancer configuration
        if: env.FRONTEND_TARGET_GROUP_ARN != '' && env.BACKEND_TARGET_GROUP_ARN != ''
        run: |
          set -euo pipefail
          echo "üîó Updating ECS service with load balancer configuration..."
          
          # First, check current service configuration
          echo "üîç Current service load balancer configuration:"
          aws ecs describe-services \
            --cluster "${{ env.ECS_CLUSTER }}" \
            --services "${{ env.ECS_SERVICE }}" \
            --query 'services[0].loadBalancers' \
            --region "${{ env.AWS_REGION }}"
          
          # Update service with load balancer configuration
          echo "üîÑ Updating service with new load balancer configuration..."
          aws ecs update-service \
            --cluster "${{ env.ECS_CLUSTER }}" \
            --service "${{ env.ECS_SERVICE }}" \
            --load-balancers \
              targetGroupArn="${{ env.FRONTEND_TARGET_GROUP_ARN }}",containerName="${{ env.CONTAINER_FRONTEND }}",containerPort=80 \
              targetGroupArn="${{ env.BACKEND_TARGET_GROUP_ARN }}",containerName="${{ env.CONTAINER_BACKEND }}",containerPort=8000 \
            --region "${{ env.AWS_REGION }}"
          
          echo "‚úÖ ECS service updated with load balancer configuration"
          
          # Wait for service to stabilize
          echo "‚è≥ Waiting for service to stabilize..."
          aws ecs wait services-stable \
            --cluster "${{ env.ECS_CLUSTER }}" \
            --services "${{ env.ECS_SERVICE }}" \
            --region "${{ env.AWS_REGION }}"
          
          echo "‚úÖ Service is stable"

      - name: Post-deployment check
        run: |
          set -euo pipefail
          echo "üîç Checking ECS service status..."
          aws ecs describe-services --cluster "${{ env.ECS_CLUSTER }}" --services "${{ env.ECS_SERVICE }}" \
            --query 'services[0].{status:status,runningCount:runningCount,pendingCount:pendingCount,desiredCount:desiredCount}'
          
          echo "üîç Checking target group health..."
          if [ -n "${{ env.BACKEND_TARGET_GROUP_ARN }}" ]; then
            aws elbv2 describe-target-health --target-group-arn "${{ env.BACKEND_TARGET_GROUP_ARN }}" \
              --query 'TargetHealthDescriptions[].{Target:Target.Id,Port:Target.Port,Health:TargetHealth.State}' \
              --output table
          fi
          
          if [ -n "${{ env.FRONTEND_TARGET_GROUP_ARN }}" ]; then
            aws elbv2 describe-target-health --target-group-arn "${{ env.FRONTEND_TARGET_GROUP_ARN }}" \
              --query 'TargetHealthDescriptions[].{Target:Target.Id,Port:Target.Port,Health:TargetHealth.State}' \
              --output table
          fi
