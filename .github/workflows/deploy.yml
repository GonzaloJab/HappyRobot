name: Build and Deploy to AWS ECS

on:
  push:
    branches: [main]
  pull_request:
    branches: [main]

env:
  AWS_REGION: eu-north-1
  ECR_BACKEND_REPO: shipments-backend
  ECR_FRONTEND_REPO: shipments-frontend
  ECS_CLUSTER: arn:aws:ecs:eu-north-1:354918374652:cluster/HappyRobot-ECS
  ECS_SERVICE: arn:aws:ecs:eu-north-1:354918374652:service/HappyRobot-ECS/shipments-taskdef-service-f8gz4zjz
  TASK_DEF_FAMILY: shipments-taskdef
  # Runtime roles used by the ECS task definition (ECS will assume these, not GitHub)
  EXECUTION_ROLE_ARN: arn:aws:iam::354918374652:role/ecsTaskExecutionRole
  TASK_ROLE_ARN: ""   # Optionally set to your app role ARN; leave empty to remove taskRoleArn
  # Container names in your task def
  CONTAINER_BACKEND: backend
  CONTAINER_FRONTEND: frontend
  # Load balancer target groups (update these with your actual target group ARNs)
  FRONTEND_TARGET_GROUP_ARN: arn:aws:elasticloadbalancing:eu-north-1:354918374652:targetgroup/APP-frontend/7a02fc7c09914764  # Set this to your frontend target group ARN
  BACKEND_TARGET_GROUP_ARN: arn:aws:elasticloadbalancing:eu-north-1:354918374652:targetgroup/APP-backend/22b79997edea2035   # Set this to your backend target group ARN

jobs:
  
  build-and-push:
    name: Build and Push Images
    runs-on: ubuntu-latest
    permissions:
      id-token: write
      contents: read

    outputs:
      backend-image: ${{ steps.build-backend.outputs.backend-image }}
      frontend-image: ${{ steps.build-frontend.outputs.frontend-image }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS credentials (OIDC - CI role)
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: arn:aws:iam::354918374652:role/GITHUB_deploy
          aws-region: ${{ env.AWS_REGION }}

      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2

      - name: Build, tag, and push backend image
        id: build-backend
        env:
          ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
          IMAGE_TAG: ${{ github.sha }}
        run: |
          set -euo pipefail
          docker build --progress=plain -t $ECR_REGISTRY/$ECR_BACKEND_REPO:$IMAGE_TAG ./backend
          docker tag $ECR_REGISTRY/$ECR_BACKEND_REPO:$IMAGE_TAG $ECR_REGISTRY/$ECR_BACKEND_REPO:latest
          docker push $ECR_REGISTRY/$ECR_BACKEND_REPO:$IMAGE_TAG
          docker push $ECR_REGISTRY/$ECR_BACKEND_REPO:latest
          echo "backend-image=$ECR_REGISTRY/$ECR_BACKEND_REPO:$IMAGE_TAG" >> "$GITHUB_OUTPUT"

      - name: Build, tag, and push frontend image
        id: build-frontend
        env:
          ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
          IMAGE_TAG: ${{ github.sha }}
          VITE_API_URL: ${{ secrets.BACKEND_URL || 'http://happyrobot-1700442240.eu-north-1.elb.amazonaws.com' }}
          VITE_API_KEY: ${{ secrets.API_KEY || 'HapRob-OTVHhErcXLu2eKkUMP6lDtrd8UNi61KZo4FvGALqem0NoJO1uWlz7OywCN0BNoNaG2x5Y' }}
        run: |
          set -euo pipefail
          docker build --progress=plain --build-arg VITE_API_URL="$VITE_API_URL" --build-arg VITE_API_KEY="$VITE_API_KEY" -t $ECR_REGISTRY/$ECR_FRONTEND_REPO:$IMAGE_TAG ./frontend
          docker tag $ECR_REGISTRY/$ECR_FRONTEND_REPO:$IMAGE_TAG $ECR_REGISTRY/$ECR_FRONTEND_REPO:latest
          docker push $ECR_REGISTRY/$ECR_FRONTEND_REPO:$IMAGE_TAG
          docker push $ECR_REGISTRY/$ECR_FRONTEND_REPO:latest
          echo "frontend-image=$ECR_REGISTRY/$ECR_FRONTEND_REPO:$IMAGE_TAG" >> "$GITHUB_OUTPUT"
          
  deploy:
    name: Deploy to ECS
    needs: build-and-push
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main'
    permissions:
      id-token: write
      contents: read

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS credentials (OIDC - CI role)
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: arn:aws:iam::354918374652:role/GITHUB_deploy
          aws-region: ${{ env.AWS_REGION }}

      - name: Debug - AWS identity
        run: |
          set -euo pipefail
          aws sts get-caller-identity
          aws --version

      - name: ECS resources check
        run: |
          set -euo pipefail
          aws ecs describe-clusters --clusters "${{ env.ECS_CLUSTER }}"
          aws ecs describe-services --cluster "${{ env.ECS_CLUSTER }}" --services "${{ env.ECS_SERVICE }}"
          aws ecs describe-task-definition --task-definition "${{ env.TASK_DEF_FAMILY }}"

      - name: Create proper task definition
        run: |
          set -euo pipefail
          echo "ðŸ”§ Creating proper task definition..."
          
          # Create a complete task definition with proper configuration
          cat > task-definition.json << 'EOF'
          {
            "family": "shipments-taskdef",
            "networkMode": "awsvpc",
            "requiresCompatibilities": ["FARGATE"],
            "cpu": "512",
            "memory": "1024",
            "executionRoleArn": "${{ env.EXECUTION_ROLE_ARN }}",
            "containerDefinitions": [
              {
                "name": "backend",
                "image": "${{ needs.build-and-push.outputs.backend-image }}",
                "portMappings": [
                  {
                    "containerPort": 8000,
                    "hostPort": 8000,
                    "protocol": "tcp"
                  }
                ],
                "essential": true,
                "environment": [
                  {
                    "name": "ALLOWED_ORIGINS",
                    "value": "http://happyrobot-1700442240.eu-north-1.elb.amazonaws.com,https://happyrobot-1700442240.eu-north-1.elb.amazonaws.com"
                  },
                  {
                    "name": "PORT",
                    "value": "8000"
                  },
                  {
                    "name": "API_KEY",
                    "value": "HapRob-OTVHhErcXLu2eKkUMP6lDtrd8UNi61KZo4FvGALqem0NoJO1uWlz7OywCN0BNoNaG2x5Y"
                  },
                  {
                    "name": "REQUIRE_API_KEY",
                    "value": "true"
                  }
                ],
                "logConfiguration": {
                  "logDriver": "awslogs",
                  "options": {
                    "awslogs-group": "/ecs/shipments",
                    "awslogs-region": "eu-north-1",
                    "awslogs-stream-prefix": "backend"
                  }
                },
                "healthCheck": {
                  "command": [
                    "CMD-SHELL",
                    "curl -f http://localhost:8000/health || exit 1"
                  ],
                  "interval": 30,
                  "timeout": 5,
                  "retries": 3,
                  "startPeriod": 60
                }
              },
              {
                "name": "frontend",
                "image": "${{ needs.build-and-push.outputs.frontend-image }}",
                "portMappings": [
                  {
                    "containerPort": 80,
                    "hostPort": 80,
                    "protocol": "tcp"
                  }
                ],
                "essential": true,
                "environment": [
                  {
                    "name": "VITE_API_URL",
                    "value": "http://happyrobot-1700442240.eu-north-1.elb.amazonaws.com"
                  },
                  {
                    "name": "VITE_API_KEY",
                    "value": "HapRob-OTVHhErcXLu2eKkUMP6lDtrd8UNi61KZo4FvGALqem0NoJO1uWlz7OywCN0BNoNaG2x5Y"
                  }
                ],
                "logConfiguration": {
                  "logDriver": "awslogs",
                  "options": {
                    "awslogs-group": "/ecs/shipments",
                    "awslogs-region": "eu-north-1",
                    "awslogs-stream-prefix": "frontend"
                  }
                },
                "healthCheck": {
                  "command": [
                    "CMD-SHELL",
                    "wget --no-verbose --tries=1 --spider http://localhost/health || exit 1"
                  ],
                  "interval": 30,
                  "timeout": 5,
                  "retries": 3,
                  "startPeriod": 60
                }
              }
            ]
          }
          EOF
          
          echo "âœ… Task definition created"
          echo "Task definition contents:"
          cat task-definition.json
      
      - name: Create log group if missing
        run: |
          set -euo pipefail
          LOG_GROUP="/ecs/shipments"
          REGION="${{ env.AWS_REGION }}"
          
          # Create the log group if missing
          EXISTS=$(aws logs describe-log-groups \
            --log-group-name-prefix "$LOG_GROUP" \
            --region "$REGION" \
            --query 'logGroups[?logGroupName==`'"$LOG_GROUP"'`] | length(@)' \
            --output text)
      
          if [ "$EXISTS" = "0" ]; then
            echo "ðŸ“˜ Creating log group: $LOG_GROUP"
            aws logs create-log-group --log-group-name "$LOG_GROUP" --region "$REGION"
            aws logs put-retention-policy --log-group-name "$LOG_GROUP" --retention-days 14 --region "$REGION" || true
          else
            echo "âœ… Log group exists: $LOG_GROUP"
          fi

      - name: Validate task definition
        run: |
          set -euo pipefail
          echo "ðŸ” Validating task definition..."
          
          # Check execution role
          execRole=$(jq -r '.executionRoleArn' task-definition.json)
          if echo "$execRole" | grep -q 'GITHUB_deploy'; then
            echo "âŒ executionRoleArn still points to GITHUB_deploy"; exit 1
          fi
          echo "âœ… Execution role looks good: $execRole"
          
          # Validate port mappings
          echo "ðŸ” Validating port mappings..."
          jq '.containerDefinitions[] | {name, portMappings}' task-definition.json
          
          # Check frontend port
          frontendPort=$(jq -r '.containerDefinitions[] | select(.name=="frontend") | .portMappings[0].containerPort' task-definition.json)
          if [ "$frontendPort" != "80" ]; then
            echo "âŒ Frontend container port is $frontendPort, expected 80"; exit 1
          fi
          
          # Check backend port
          backendPort=$(jq -r '.containerDefinitions[] | select(.name=="backend") | .portMappings[0].containerPort' task-definition.json)
          if [ "$backendPort" != "8000" ]; then
            echo "âŒ Backend container port is $backendPort, expected 8000"; exit 1
          fi
          
          echo "âœ… Port mappings look good"

      - name: Deploy Amazon ECS task definition
        run: |
          set -euo pipefail
          echo "ðŸš€ Deploying task definition..."
          
          # Register the new task definition
          TASK_DEF_ARN=$(aws ecs register-task-definition \
            --cli-input-json file://task-definition.json \
            --query 'taskDefinition.taskDefinitionArn' \
            --output text \
            --region "${{ env.AWS_REGION }}")
          
          echo "âœ… Task definition registered: $TASK_DEF_ARN"
          
          # Update the service
          aws ecs update-service \
            --cluster "${{ env.ECS_CLUSTER }}" \
            --service "${{ env.ECS_SERVICE }}" \
            --task-definition "$TASK_DEF_ARN" \
            --region "${{ env.AWS_REGION }}"
          
          echo "âœ… Service updated with new task definition"

      - name: Update ECS service with load balancer configuration
        if: env.FRONTEND_TARGET_GROUP_ARN != '' && env.BACKEND_TARGET_GROUP_ARN != ''
        run: |
          set -euo pipefail
          echo "ðŸ”— Updating ECS service with load balancer configuration..."
          
          # Update service with load balancer configuration
          aws ecs update-service \
            --cluster "${{ env.ECS_CLUSTER }}" \
            --service "${{ env.ECS_SERVICE }}" \
            --load-balancers \
              targetGroupArn="${{ env.FRONTEND_TARGET_GROUP_ARN }}",containerName="${{ env.CONTAINER_FRONTEND }}",containerPort=80 \
              targetGroupArn="${{ env.BACKEND_TARGET_GROUP_ARN }}",containerName="${{ env.CONTAINER_BACKEND }}",containerPort=8000 \
            --region "${{ env.AWS_REGION }}"
          
          echo "âœ… ECS service updated with load balancer configuration"
          
          # Wait for service to stabilize
          echo "â³ Waiting for service to stabilize..."
          aws ecs wait services-stable \
            --cluster "${{ env.ECS_CLUSTER }}" \
            --services "${{ env.ECS_SERVICE }}" \
            --region "${{ env.AWS_REGION }}"
          
          echo "âœ… Service is stable"

      - name: Post-deployment check
        run: |
          set -euo pipefail
          echo "ðŸ” Checking ECS service status..."
          aws ecs describe-services --cluster "${{ env.ECS_CLUSTER }}" --services "${{ env.ECS_SERVICE }}" \
            --query 'services[0].{status:status,runningCount:runningCount,pendingCount:pendingCount,desiredCount:desiredCount}'
          
          echo "ðŸ” Checking target group health..."
          if [ -n "${{ env.BACKEND_TARGET_GROUP_ARN }}" ]; then
            echo "Backend target group health:"
            aws elbv2 describe-target-health --target-group-arn "${{ env.BACKEND_TARGET_GROUP_ARN }}" \
              --query 'TargetHealthDescriptions[].{Target:Target.Id,Port:Target.Port,Health:TargetHealth.State}' \
              --output table || echo "âš ï¸ Could not check backend target group health (permission issue)"
          fi
          
          if [ -n "${{ env.FRONTEND_TARGET_GROUP_ARN }}" ]; then
            echo "Frontend target group health:"
            aws elbv2 describe-target-health --target-group-arn "${{ env.FRONTEND_TARGET_GROUP_ARN }}" \
              --query 'TargetHealthDescriptions[].{Target:Target.Id,Port:Target.Port,Health:TargetHealth.State}' \
              --output table || echo "âš ï¸ Could not check frontend target group health (permission issue)"
          fi
          
          echo "âœ… Deployment completed successfully!"
          echo "ðŸŒ Your application should be accessible at: http://happyrobot-1700442240.eu-north-1.elb.amazonaws.com"
